import { ArticleLayout } from '@/components/ArticleLayout'

export const meta = {
  author: 'Paul Gradie',
  date: '2023-10-06',
  title: 'Biology teaches us to make small changes to our software',
  description: 'Small incremental changes do more for us than make changes digestbile - they keep our products alive',
}

import { getArticlesProps } from '@/lib/getArticlesProps'
export async function getStaticProps() {
  return await getArticlesProps()
}
export default (props) => <ArticleLayout meta={meta} {...props} />


# Biology is the study of life.

When we think of life, we often anthropomorphize and immediately think of ourselves and our fellow humans. “A day in the life of…”, or “life is hard… because I have to work every day”. But some folks even take the next leap and think something along the lines of, “the struggles of wildlife” or “nature is full of life”. That is of course all true, and biology is absolutely concerned with these higher level perceptions of life.

Life involves the most fundamental of properties of the universe, because life is simply a collection of atoms all interacting in complex ways. When we study atoms, we might be studying life, or chemistry, or fundamental physics, or any of their many subdomains. And that is because they’re all different facets of the same thing: Energy and its relationship with space-time.

Life is all about this really strange phenomenon we observe in the universe where wisps of energy that have undergone something in the spirit of ‘condensation’, have begun to spontaneously work against the natural flow of entropy in the universe - a state change which tends towards increasing over time. When life enters the picture, the amount of disorder doesn’t increase any more - for a time it decreases. In other words, the energy which should ultimately disperse over time to homogeneously fill out the volume of the universe does the other thing - it organizes and becomes more ordered.

We don’t really yet have a good answer for why this happens in the universe, but it does happen. And so our scientists seek to understand the universe. Each major field we’ve established simply deals with one ‘scope’ or level, so to speak.

### Physics:
What is matter and its relationship with energy? How does matter behave? What is the universe?

### Chemistry:
What is the composition of matter and how is it composed? In what ways can matter be combined or broken apart? What are the states of matter?

### Biology:
How does organic chemistry and physics result in this thing we call life? How does this emergent property of self replication and higher order self organization come to be? How does life propagate itself?

Life is a system that not only exhibits complex higher order emergent behavior, but also the capability of conferring changes onto itself in order to optimize for an objective. When we think of life, we are thinking of things that exist as energy in this universe.

**The word for this is evolution.**

Evolution is a process over which generations of finite-lasting individuals are produced, where each generation holds a small, incremental change from the previous generation. This is the only concern the theory - at its core - really has. It doesn’t address the true ‘why’, it simply gives us an explanation for the many phenomena we observe. It is critical to make the following distinction: Evolution and ‘change over time’ are not the same thing, and I do not intend to conflate the two here. Unfortunately, in contemporary language, the word ‘Evolution’ is frequently used to mean ‘change over time’. Someone might incorrectly speak of ‘the evolution of the sun’ or ‘as you learn, you evolve as an individual’. And while there might be some way to reconcile personal development with the idea of evolution, the two should generally be kept separate and distinct because in the abstract they are completely different.

Life exploits the algorithm of evolution as its core strategy for ensuring self-propagation. The primary concern of life, from our best educated guesses, is to simply persist. This is actually an excellent strategy, because as we noted earlier, the universe tends towards the increase of entropy, or the amount of disorder, in the universe. That means that as energy continues to dissipate throughout the universe, the state of the universe changes from moment to moment. And recall that matter is energy. So when I say that ‘energy continues to dissipate’, I’m also saying that ‘matter like atoms will continue to move around and eventually spread out’. Since the state of the universe is always changing, a strategy that constantly updates to account for a change of state makes a lot of sense.

Interestingly, the strategy itself came from a process of evolution that existed since before the dawn of life in the universe. If we accept the prevailing theory of the origin of the universe - the big bang theory - then we have an explanation for the creation of countless galaxies across the universe. Each of these hundreds of billions of galaxies can be considered a simulation, which is playing out some of the possible things that can happen when large amounts of energy are left to its own devices. Clearly one of these possibilities is life as we know it. So from that philosophical perspective, at least one of the purposes of the universe is to facilitate life - or in other words, life is one of the things that will eventually play out in the universe. So in a sense, the energy of the universe takes an active role in the evolution of life in the universe - and in particular on our planet. And in that sense, energy itself has taken to incremental changes - this galaxy vs that galaxy, this solar system vs that solar system, and so on - as part of the legacy of life which began with the origin of the universe.

Let’s recap. Biology is just one of several fields that are ultimately concerned with the same things: the universe. Everything in the universe is made from energy and that means energy exhibits a behavior of evolution, which is the relatively small incremental changes from one generation to the next, in order to ensure the persistence of pockets of decreased entropy. This is a very good strategy because it allows these pockets of energy to change over generations and increases the chance that the changing state of the universe doesn’t prevent the persistence of these lower entropy pockets of energy.

In more common language: Life, like plants and animals on earth, are a feature of energy in this universe, and life evolves in order to survive.

It is quite amazing.

Life on our planet has been evolving for a very long time - billions of years. In that time, the organisms that have had the (mis)fortune of living here encountered a lot of problems they’ve had to solve. Temperature. Nutrients. Reproduction. Flying, digging, hunting, hiding. All manner of problems. Take for example, Darwin’s finches - which all occupied a small island with a few different kinds of nuts. Over time, these birds created offspring that had increasingly differently shaped beaks - until one day an old man with a beard had a good hard look at them and realized what must have happened. Evolution. This process, he concluded, must have led to very successful versions of this bird which were quite capable and adept at survival.

And this is where we begin to see an intersection with software development.
When we architect software, we always start with a ‘first iteration’, which always starts with ‘a first line of code’. Initially, we add lines and lines of code at basically no cost or risk. While we are intending to ‘bring a product to life’ for some consumer, the initial lines are poured in with no risk since the product is not yet alive. So it likely was with the first molecules of life on our planet. Once life was finally established - once the product is built and is in the hands of the consumer - then the risk becomes real. The risk that life might be snuffed out.

There are a lot of humans. There are a lot of ants. Most species have a relatively large number of individuals amongst their populations. This is because the survival strategy for life on this planet has effectively settled on massive concurrency when applying the strategy of evolution. If we consider only sexually reproducing animals, every pair tends to have more than one offspring - which means the ever increasing size of the population and evolution is the incremental change between the parents and the offspring.
And we can see how successful this process is. In fact, when animals don’t do this, they tend to go extinct.
I hope it is beginning to become clear that writing software is a lot like the evolution of life. Our products are the organization of life - you can think of a product or application like its own species, and in order to adapt them to an ever changing universe of customers and their demands, we must ensure that they evolve. Since we build and deploy software, we don’t really change our software over time. Instead, we create offspring - versions. And we ship these versions in the hope that they don’t fail to meet the expectations of the customer and die.

# Keeping software alive as it evolves through incremental changes

Biology gives us an excellent model for establishing a basis for how we make changes to our software. The model: Evolution. Species evolve by making copies of themselves with incremental, likely imperceptible changes. Species make many, many copies with small changes, which lead to a large number of versions of that species. The field of software development has converged on a similar solution: version control.

Most of us use Git in order to track changes to our software. When we wish to make a change (or evolve) our codebase, the first thing we’ll do is pull all of the latest changes on the default branch, and then check out a new branch. When we create a new branch, we are making a new copy of our application’s source which will then be mutated with various changes and/or additions. And as many of us know - it is not uncommon for branches to never make it to production. Just making changes and additions can lead to a branch being discarded for any of a countless number of reasons. As such, it stands to reason that the more changes you include in your branch, the more likely it is that there will be some change present that will cause the branch to no longer be viable.

Then there is the review process.

Requesting that new changes be pulled into the master branch (or merged in, if you prefer) is usually accompanied by a formal review process. This means someone else will need to invest time and energy into consuming and thinking critically about your changes - which will add another opportunity for your branch to be rejected. By keeping changes incremental, you provide a lower barrier to entry for the folks that will review your changes. This in turns eliminates additional reasons that may result in your branch from being rejected.

The point here is that incremental changes lower the risk and simplify the review of your changes. Your code is more likely to be accepted, less likely to cause damage, and is generally easier to understand when you deliver small, incremental changes.

# Software Architecture Design and Compatibility with Incremental Changes

The biggest challenge I see at organizations with respect to delivering incremental changes is usually due to the general architecture of the application.This post isn’t focused on the topic of ‘good’ software architecture, however it is worth mentioning that there are various design philosophies and techniques available to help guide us towards writing maintainable code.

My current favorites are SOLID design principles and Domain Driven Design. Together, these two techniques drive us towards creating application components that have few concerns (ideally one), clear lines of responsibility, high cohesion and low coupling, and other characteristics that make it easy to deliver small extensions to the software without needing to modify large swaths of code.

# Delivering Small Incremental Change

The final stage of any software change is of course the CI/CD pipeline (continuous integration / continuous deployment). These pipelines are responsible for automating the process of building, testing and delivering software to end users. And without these pipelines, it is very difficult to deliver incremental changes to customers.

At this point, it may be prudent to clarify what I actually mean by incremental changes.

When you design your applications in ways that facilitate delivery of small incremental changes, you increase the probability that the new version of your software will survive the lifecycle. And with a CI/CD pipeline, you can ship these changes as soon as they come out, decreasing the feedback cycle run time.

The concept of incremental change is at the heart of both biological evolution and software development. In biology, each generation represents an "increment" that carries changes—sometimes subtle, other times significant—from its predecessor. Likewise, in software, each version or release serves as a distinct increment, building on its preceding version. Incremental changes provide a form of resilience. For life, this resilience manifests as an adaptive response to environmental factors. In software, it presents as flexibility and ease of maintenance.

In biology, DNA acts as the blueprint for all organic life forms. It contains the instructions for building and maintaining the organism. Each gene encodes specific traits, guiding the construction of proteins that will perform various roles within the cells. This is very much akin to how source code serves as the blueprint for a software application, defining its features and behaviors.

## What is DNA

Deoxyribonucleic Acid (DNA) is a molecule that contains the genetic instructions used in the growth, development, functioning, and reproduction of all known living organisms. It's essentially a string of nucleotides, each comprising a sugar, a phosphate group, and a nitrogenous base. These nucleotides are organized into two long strands that spiral into the familiar double helix structure.

DNA can change or mutate in various ways: base substitutions, insertions, deletions, and more. These mutations can happen due to random errors during replication, environmental factors like radiation, or even through the intervention of other molecules. Some mutations confer advantages and are passed on to future generations, facilitating evolution.

DNA replication is a semi-conservative process wherein each strand serves as a template for a new strand. The process begins with the unwinding of the double helix, followed by the addition of new nucleotides that are complementary to the template strand. This results in two new DNA molecules, each containing one old and one new strand.

Cells have several mechanisms to correct DNA replication errors. Enzymes like DNA polymerase have proofreading capabilities, identifying and fixing inaccuracies. More complex repair pathways, such as mismatch repair and nucleotide excision repair, further ensure genomic fidelity.

A change in DNA, or a mutation, can result in various outcomes. It might be benign or even beneficial, leading to a new advantageous trait. Conversely, it could be detrimental, causing diseases or impairing function. Some mutations may even be fatal.

The genetic code consists of a set of rules defining how sequences in DNA are translated into proteins. These rules are determined by codons—triplets of nucleotides that specify a particular amino acid. The genetic code acts as a kind of "syntax," ensuring that DNA changes are expressed in a controlled manner.

## The Relationship with Software Development

In software development, we manage change through version control systems like Git. Similar to how DNA serves as a blueprint for organisms, source code defines the functionality of software. When we want to introduce changes, we create new "branches," isolating modifications to prevent unintended consequences. This approach allows for rigorous testing and review before changes are merged back into the main codebase, similar to how mutations in DNA undergo natural selection.

Branching in version control serves a similar purpose to biological diversification. It allows for isolated environments where changes can be made and tested without affecting the core system. This is akin to how a subpopulation of a species might become isolated and evolve separately from the main population, eventually leading to new species if the changes are significant.

Incremental changes are key to both biological evolution and effective software development. Small, incremental mutations in DNA over millions of years have led to the biodiverse world we see today. Similarly, the most robust and adaptable software systems are often those that have been refined incrementally over time. Small changes are easier to test, review, and integrate, reducing the risk of catastrophic failure.

## Designing software to facilitate incremental change

Utilizing design principles like SOLID and Domain-Driven Design can make software more modular and extensible, thereby making it easier to implement incremental changes. These principles help create a codebase with low coupling and high cohesion, where each component or module has a single, well-defined responsibility.

Continuous integration and continuous deployment (CI/CD) pipelines facilitate the rapid and automated testing and deployment of incremental changes. This allows for immediate feedback and quicker iterations, analogous to how advantageous genetic mutations are quickly propagated through natural selection.

In biology, "testing" happens through natural selection, where environmental pressures validate or negate genetic mutations. In software, rigorous testing, often automated through CI/CD pipelines, ensures that new changes don't introduce regressions and that they meet the desired functional and performance criteria. Your experience with Sailfish seems particularly relevant here, as performance testing is a critical subset of this "natural selection" in software.

Both genetic mutations and software bugs can be unplanned and have a wide range of consequences. They can be beneficial, neutral, or detrimental. The difference lies in the time scale and the mechanism for correction. While natural selection takes generations to "fix" harmful mutations, software bugs can often be addressed more swiftly through debugging and patches.

Natural selection acts as a filter for biological traits, favoring those that offer a survival advantage. Similarly, market feedback serves as a selective pressure in the software industry. Products that meet user needs and expectations are more likely to thrive, while those that don't adapt will likely fail. In both cases, the principle is the same: adapt or perish.

In summary, the idea of incremental changes and how they are managed, tested, and deployed has fascinating parallels between biological evolution and software development. Understanding these similarities can offer valuable insights into the challenges and best practices of managing complex, adaptive systems—whether they're made of cells or code.
